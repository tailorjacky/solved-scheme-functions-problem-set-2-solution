Download Link: https://assignmentchef.com/product/solved-scheme-functions-problem-set-2-solution
<br>
Write the following Scheme functions: A. “fracktorial” – takes an integer and computes the “fracktorial” of the integer. The “fracktorial” of a number is similar to the factorial, except that only the even values are multiplied together. For example, the “fracktorial” of 8 is 8*6*4*2 = 384, and would be called with (fracktorial 8), which should return 384. Similarly the “fracktorial” of 7 would be 6*4*2 = 48, and would be called with (fracktorial 7). Assume that the function is defined only for integers of size at least 1, and that the fracktorial of 1 is defined to be equal to 1. B. “reverseListHalves” – takes a list and reverses the elements of both the left half and the right half of the list. For example, (reverseListHalves ‘(1 2 3 4 5 6 7 8)) would return (4 3 2 1 8 7 6 5). Your function should also work on odd-length lists, in which case it would leave the center item unmoved. For example: (reverseListHalves ‘(1 2 3 4 5 6 7 8 9)) would return (4 3 2 1 5 9 8 7 6). You will probably find it useful to break the problem down and create some helper functions. C. “sumPicker” – takes two lists; the first list is the “picker”, and the second list is the “data”. Your task is to sum up each of the numbers in the “data” list referenced by the “picker” list. For example: (sumPicker ‘(2 4 7) ‘(8 3 2 9 1 1 6 6 7)) would be 18, because the “picker” list says to add up the 2nd, 4th, and 7th items in the “data” list. The 2nd item is 3, the 4th item is 9, and the 7th item is 6. Therefore the total is 3 + 9 + 6 which equals 18. D. “countEvens” – takes a list of integers, possibly nested, and counts how many of the integers are even. For example, (countEvens ‘(2 3 (4 (7 6) 5))) should return 3, because there are three even numbers in the nested list: 2, 4, and 6. E. “applyUntilTooBig” – takes as input one function F, and an integer N. It then applies the function F to the integer repeatedly, until the value of the integer first exceeds 100. It then returns that value. For example, (applyUntilTooBig double 5) would return 160. because 5 doubled is 10, then 20, then 40, then 80, then 160. Of course, the function should work for any reasonable function F, and any reasonable value N. F. A function “makeExploder”, that takes as input two numbers A and B. It then builds and returns an “exploder” function based on A and B. The exploder function that is produced (by your function makeExploder) would have the property that it takes as input a list, adds A to every item in the list, then multiplies every item in the list by B. For example, if makeExploder was called as follows: (makeExploder 5 7) a function would be produced that takes as input a list and “explodes” it. For example if the input list were (4 8 2), the output list would be (63 91 49)… because each item in the list was added to 4, and then multiplied by 7. Thus, if the original call had been made as follows: (define S (makeExploder 5 7)) then the the produced function S would behave as follows: (S ‘(4 8 2)) *** would return (63 91 49) (S ‘(-2 3)) *** would return (21 56) Your task is just to write makeExploder. You may find it useful to write one or more utility functions. Of course, makeExploder should work for ANY input pair of integers, not just the one shown above.